> 以下是关于程序运行时的一些拓展说明和运行细节，可以有助于你理解程序的调用和输出结果

# 问题的限定

由于问题描述中有许多不严谨或不清晰的地方，在这里统一做出规定。

1. 任务要求的本质：求所有符合节点数量要求的自包含子图。
    
    我们认为，除"id"之外的属性，如果出现了其他节点id,则表明该节点调用了其他节点。在图状结构构造函数`Graphicalize()`中，我们认为这属于**单向关系**。

    我们认为仅在文件中出现的节点"id"才代表节点，如果你在某个非id属性中看到出现了疑似是id的字符串，但这个字符串无法对应文件中任何一个节点id,那么我们认为：**这不是节点id, 只是一串代表某个属性的字符串**

2. 关于在其他属性中，id需要以怎样的形式出现才能够判定为具有连接关系，程序提供了**两种**理解和实现代码：
   1. 认为必须字符串精准匹配，也即属性的value必须严格等于某个id值，这是程序处理时的默认规则
   2. 认为可以出现在字符串字串中，比如某个节点id是`hjkhuiui`,而其他结点中某个属性的值出现了`set:hjkhuiui`,那我我们也认为该节点被调用，需要构造连接关系。这部分代码包含在注释中

3. 调用工具的路径问题

    理论上，你使用工具时，应该是在`build/`目录下，所以你需要调用`tool`时正确的调用方式是`./tool`，至少在Linux上是这样的。

    而关于后面第一个参数的路径，你应该是相对于**项目根目录**来确定。这也许有点奇怪，但是我在代码中是默认给你的路径添加了前缀`../`的，所以你的默认文件/文件夹路径要相对于项目根目录。

    例如，你想要处理项目根目录下的`test/`文件夹，你应该进入`build/`目录，然后`./tool test 1 4`


# 关于拓展功能

1. 用户可以输入额外的参数来代表构建关系时需要忽略的某些属性，这个功能已经成功实现，并且`tool`可以自动处理这两种输入情况。

2. 关于输出子图的连通性问题。

    首先我们需要明确这里的连通性是指**弱连通性**，程序默认生成弱连通的子图，这样可以防止子模块文件过多。

    但是得益于程序的良好结构化，你可以在`CoreAlgor.cpp`第**182**行自行觉得是否需要注释`CheckConnected()`函数，如果注释掉，结果会生成含有不连通的自包含子图。

